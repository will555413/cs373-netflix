#!/usr/bin/env python3

from numpy import mean, sqrt, square, subtract
from CacheFactory import year2index, print_lst

# ---------------
# user_cache_read
# ---------------

def user_cache_read (user_cache) :
    """
    Reads the user cache generated by the CacheFactory.py
    user_cache the movie cache file generated 
    """
    ucache = {}
    for line in user_cache:
        uid, p1, p2, p3, p4, p5 = line.split()
        ucache[int(uid)] = [float(p1), float(p2), float(p3), float(p4), float(p5)]
    return ucache

# --------------
# mov_cache_read
# --------------

def mov_cache_read (movie_cache) :
    """
    Reads the movie cache generated by the CacheFactory.py
    movie_cache the movie cache file generated 
    """
    mcache = []
    for line in movie_cache:
        yr, rat = line.split()
        mcache.append([int(yr), float(rat)])
    return mcache
    

# ------------
# netflix_eval
# ------------

def netflix_eval (mid, uid, mcache, ucache) :
    """
    Predict a user's rating upon a specific movie using movie and user caches
    mid the movie id
    uid the user id
    mcache the movie cache
    ucache the user cache
    """
    yr = year2index(mcache[mid-1][0])
    mrating = mcache[mid-1][1]

    urating = estimate(yr, ucache[uid])
    return mrating *.25 + urating * .75
    

# --------
# estimate
# --------

def estimate (index, ulst):
    """
    Helper function that estimate the user rating that's closest to the era specified.
    Calculate the average ratings from three eras where the era specified get more weight.
    If the user never rate a movie from the era specified, find the two closest rated era and get the average with equal weight
    index the era specified
    ulst the user's average rating for each era
    """
    earlier = 0
    i = index - 1
    while i >= 0:
        earlier = ulst[i]
        if earlier != 0:
            break
        i-=1

    now = ulst[index]

    later = 0
    i = index + 1
    while i<len(ulst):
        earlier = ulst[i]
        if earlier != 0:
            break
        i+=1

    # # if only one of three is valid
    # if now+earlier+later == now or now+earlier+later == earlier or now+earlier+later == later:
    #     return now+earlier+later
    assert now != 0 or earlier != 0 or later != 0

    if now != 0:
        if earlier != 0 and later != 0:
            return now*.5 + earlier*.25 + later*.25
        elif earlier != 0:
            return (now*2+earlier)/3
        return (now*2+later)/3
    elif earlier != 0 and later != 0:
        return earlier*.5 + later*.5
    elif earlier != 0:
        return earlier
    return later

# -------------
# collatz_solve
# -------------

def netflix_solve (r, w) :
    """
    Core of the Netflix.py
    Calls functions to construct caches, then predict the rating of specified users on specified movies
    r the input stream
    w the output stream
    """
    ucache = user_cache_read(open('/u/wc6892/Documents/cs373-netflix/wc6892-ucache.txt', 'r'))
    mcache = mov_cache_read(open('/u/wc6892/Documents/cs373-netflix/wc6892-mcache.txt', 'r'))
    # User cache and movie cache that structured similarly to the caches in CacheFactory
    # Created to stored the caches generated by teh factory

      
    mid = 0
    for s in r :
        if s.replace('\n', '').endswith(':'):
            mid = int(s.replace(':', ''))
            w.write(s)
            continue
        uid = int(s)
        v   = netflix_eval(mid, uid, mcache, ucache)
        w.write(str(round(v, 2))+"\n")
