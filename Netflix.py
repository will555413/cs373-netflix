#!/usr/bin/env python3

from numpy import mean, sqrt, square, subtract
from requests import get
import os

# ---------------
# user_cache_read
# ---------------

def user_cache_read (user_cache) :
    """
    Reads and returns the user offsets cache generated by the CacheFactoryOff.py as dictionary
    The cache recorded the offset of average rating given by each user relative to average of all ratings recorded 
    user_cache the user offsets cache file generated 
    """
    ucache = {}
    for line in user_cache:
        uid, rat = line.split(' ')
        ucache[int(uid)] = float(rat)
    return ucache

# --------------
# mov_cache_read
# --------------

def mov_cache_read (movie_cache) :
    """
    Reads and returns the movie cache generated by the CacheFactoryOff.py as list
    The first line of the cache recorded the average of all ratings recorded
    The rest of the cache recorded the offset of average rating each movie received relative to average of all ratings recorded
    The first entry also offset the indices assigned to each movie offset so that the movie id could be used an index
    movie_cache the movie offsets cache file generated 
    """
    mcache = []
    for line in movie_cache:
        mcache.append(float(line))
    return mcache

# --------------
# probe_read
# --------------

def probe_read (probe, actual_rating, current) :
    """
    Reads in probe.txt and its corresponding actual rating.
    While reading, conpare to the input set IN and search for appropriate actual rating
    probe the probe.txt
    actual_rating the probe_actual.txt provided by classmate
    current the list represent the current input
    """
    OUT = []
    IN = iter(current)

    pr = next(probe)
    ac = next(actual_rating)
    ID = next(IN)

    while True:
        if ID.find(':')>-1:
            while pr != ID :
                pr = next(probe)
                ac = next(actual_rating)
            pr = next(probe)
            ac = next(actual_rating)
            ID = next(IN)

        if int(ID) == int(pr):
            OUT.append(int(ac))
        try:
            pr = next(probe)
            ac = next(actual_rating)
            ID = next(IN)
        except StopIteration:
            return OUT



# -------------
# netflix_solve
# -------------

def netflix_solve (r, w) :
    """
    Core of the Netflix.py
    Calls functions to construct caches, then predict the rating of specified users on specified movies using offsets
    r the input stream
    x the output stream
    """
    # if os.path.isfile('/u/ebanner/netflix-tests/wc6892-ucacheoff.txt') and os.path.isfile('/u/ebanner/netflix-tests/wc6892-mcacheoff.txt'):
    #     # Read cache from the file /u/ebanner/netflix-tests/path/to/caches
    #     ufile = open('/u/ebanner/netflix-tests/wc6892-ucacheoff.txt')
    #     mfile = open('/u/ebanner/netflix-tests/wc6892-mcacheoff.txt')
    # else:
    #     # Read cache from HTTP
    #     ufile = requests.get('http://www.cs.utexas.edu/users/ebanner/netflix-tests/wc6892-ucacheoff.txt')
    #     mfile = requests.get('http://www.cs.utexas.edu/users/ebanner/netflix-tests/wc6892-mcacheoff.txt')

    ucache = user_cache_read(open('/u/wc6892/Documents/netflix-tests/wc6892-ucacheoff.txt', 'r'))
    mcache = mov_cache_read(open('/u/wc6892/Documents/netflix-tests/wc6892-mcacheoff.txt', 'r'))
    # User cache and movie cache that stored offsets of each movie and user relative to the global average
    # Created to stored the caches generated by the factory

    predict = []
    actual = []
    
    mid = 0
    for s in r :
        if s.find(':')>-1:
            mid = int(s.replace(':', ''))
            w.write(s)
            actual.append(s)
            continue
        uid = int(s)
        v = mcache[0]+mcache[mid]+ucache[uid]
        predict.append(v)
        actual.append(s)
        w.write(str(round(v, 2))+"\n")

    actual = probe_read(open('/u/wc6892/Documents/cs373-netflix/probe.txt','r'), open('/u/wc6892/Documents/cs373-netflix/probe_actual.txt','r'), actual)

    assert len(actual) == len(predict)

    w.write("RMSE: "+str(round(sqrt(mean(square(subtract(actual, predict)))), 2))+"\n")